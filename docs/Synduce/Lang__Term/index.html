<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lang__Term (Synduce.Lang__Term)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">Synduce</a> &#x00BB; Lang__Term</nav><h1>Module <code>Lang__Term</code></h1></header><div class="spec module" id="module-O"><a href="#module-O" class="anchor"></a><code><span class="keyword">module</span> O = Base.Option</code></div><dl><dt class="spec value" id="val-dummy_loc"><a href="#val-dummy_loc" class="anchor"></a><code><span class="keyword">val</span> dummy_loc : Stdlib.Lexing.position * Stdlib.Lexing.position</code></dt></dl><dl><dt class="spec module" id="module-Attributes"><a href="#module-Attributes" class="anchor"></a><code><span class="keyword">module</span> <a href="Attributes/index.html">Attributes</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Variables have unique integer ids but two variables can have the same name. Additional information can be added via variable attributes. For example, a variable can be a Terminal or a NonTerminal in the context of a pattern matching recursion scheme.</p></dd></dl><dl><dt class="spec type" id="type-variable"><a href="#type-variable" class="anchor"></a><code><span class="keyword">type</span> variable</code><code> = </code><code>{</code><table class="record"><tr id="type-variable.vname" class="anchored"><td class="def field"><a href="#type-variable.vname" class="anchor"></a><code>vname : Base.string;</code></td></tr><tr id="type-variable.vid" class="anchored"><td class="def field"><a href="#type-variable.vid" class="anchor"></a><code>vid : Base.int;</code></td></tr><tr id="type-variable.vattrs" class="anchored"><td class="def field"><a href="#type-variable.vattrs" class="anchor"></a><code>vattrs : <a href="Attributes/index.html#type-t">Attributes.t</a>;</code></td></tr></table><code>}</code></dt></dl><div class="spec module" id="module-Variable"><a href="#module-Variable" class="anchor"></a><code><span class="keyword">module</span> <a href="Variable/index.html">Variable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-VarSet"><a href="#module-VarSet" class="anchor"></a><code><span class="keyword">module</span> <a href="VarSet/index.html">VarSet</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Terms.</p></aside><div class="spec module" id="module-Binop"><a href="#module-Binop" class="anchor"></a><code><span class="keyword">module</span> <a href="Binop/index.html">Binop</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Unop"><a href="#module-Unop" class="anchor"></a><code><span class="keyword">module</span> <a href="Unop/index.html">Unop</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Operator"><a href="#module-Operator" class="anchor"></a><code><span class="keyword">module</span> <a href="Operator/index.html">Operator</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-OpSet"><a href="#module-OpSet" class="anchor"></a><code><span class="keyword">module</span> <a href="OpSet/index.html">OpSet</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Constant"><a href="#module-Constant" class="anchor"></a><code><span class="keyword">module</span> <a href="Constant/index.html">Constant</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-fpattern"><a href="#type-fpattern" class="anchor"></a><code><span class="keyword">type</span> fpattern</code><code> = </code><table class="variant"><tr id="type-fpattern.FPatVar" class="anchored"><td class="def constructor"><a href="#type-fpattern.FPatVar" class="anchor"></a><code>| </code><code><span class="constructor">FPatVar</span> <span class="keyword">of</span> <a href="index.html#type-variable">variable</a></code></td></tr><tr id="type-fpattern.FPatTup" class="anchored"><td class="def constructor"><a href="#type-fpattern.FPatTup" class="anchor"></a><code>| </code><code><span class="constructor">FPatTup</span> <span class="keyword">of</span> <span><a href="index.html#type-fpattern">fpattern</a> Base.list</span></code></td></tr></table></dt><dd><p>Simple patterns for function arguments: a fpattern is either a variable or a tuple of patterns.</p></dd></dl><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> pattern</code><code> = </code><table class="variant"><tr id="type-pattern.PatAny" class="anchored"><td class="def constructor"><a href="#type-pattern.PatAny" class="anchor"></a><code>| </code><code><span class="constructor">PatAny</span></code></td></tr><tr id="type-pattern.PatVar" class="anchored"><td class="def constructor"><a href="#type-pattern.PatVar" class="anchor"></a><code>| </code><code><span class="constructor">PatVar</span> <span class="keyword">of</span> <a href="index.html#type-variable">variable</a></code></td></tr><tr id="type-pattern.PatConstant" class="anchored"><td class="def constructor"><a href="#type-pattern.PatConstant" class="anchor"></a><code>| </code><code><span class="constructor">PatConstant</span> <span class="keyword">of</span> <a href="Constant/index.html#type-t">Constant.t</a></code></td></tr><tr id="type-pattern.PatTuple" class="anchored"><td class="def constructor"><a href="#type-pattern.PatTuple" class="anchor"></a><code>| </code><code><span class="constructor">PatTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-pattern">pattern</a> Base.list</span></code></td></tr><tr id="type-pattern.PatConstr" class="anchored"><td class="def constructor"><a href="#type-pattern.PatConstr" class="anchor"></a><code>| </code><code><span class="constructor">PatConstr</span> <span class="keyword">of</span> Base.string * <span><a href="index.html#type-pattern">pattern</a> Base.list</span></code></td></tr></table></dt><dd><p>More complex patterns are used in match-cases. In the current implementation, this is only used as a way to translate a PMRS back to a set of mutually recursive functions.</p></dd></dl><dl><dt class="spec type" id="type-termkind"><a href="#type-termkind" class="anchor"></a><code><span class="keyword">type</span> termkind</code><code> = </code><table class="variant"><tr id="type-termkind.TApp" class="anchored"><td class="def constructor"><a href="#type-termkind.TApp" class="anchor"></a><code>| </code><code><span class="constructor">TApp</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * <span><a href="index.html#type-term">term</a> Base.list</span></code></td><td class="doc"><p>A function application.</p></td></tr><tr id="type-termkind.TBin" class="anchored"><td class="def constructor"><a href="#type-termkind.TBin" class="anchor"></a><code>| </code><code><span class="constructor">TBin</span> <span class="keyword">of</span> <a href="Binop/index.html#type-t">Binop.t</a> * <a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A binary operation.</p></td></tr><tr id="type-termkind.TBox" class="anchored"><td class="def constructor"><a href="#type-termkind.TBox" class="anchor"></a><code>| </code><code><span class="constructor">TBox</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A boxed term, used in transformation to &quot;protect&quot; its contents.</p></td></tr><tr id="type-termkind.TConst" class="anchored"><td class="def constructor"><a href="#type-termkind.TConst" class="anchor"></a><code>| </code><code><span class="constructor">TConst</span> <span class="keyword">of</span> <a href="Constant/index.html#type-t">Constant.t</a></code></td><td class="doc"><p>A constant.</p></td></tr><tr id="type-termkind.TData" class="anchored"><td class="def constructor"><a href="#type-termkind.TData" class="anchor"></a><code>| </code><code><span class="constructor">TData</span> <span class="keyword">of</span> Base.string * <span><a href="index.html#type-term">term</a> Base.list</span></code></td><td class="doc"><p>A datatype constructor.</p></td></tr><tr id="type-termkind.TFun" class="anchored"><td class="def constructor"><a href="#type-termkind.TFun" class="anchor"></a><code>| </code><code><span class="constructor">TFun</span> <span class="keyword">of</span> <span><a href="index.html#type-fpattern">fpattern</a> Base.list</span> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A function, where each argument capture by a f-pattern.</p></td></tr><tr id="type-termkind.TIte" class="anchored"><td class="def constructor"><a href="#type-termkind.TIte" class="anchor"></a><code>| </code><code><span class="constructor">TIte</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A conditional.</p></td></tr><tr id="type-termkind.TMatch" class="anchored"><td class="def constructor"><a href="#type-termkind.TMatch" class="anchor"></a><code>| </code><code><span class="constructor">TMatch</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * <span><a href="index.html#type-match_case">match_case</a> Base.list</span></code></td><td class="doc"><p>A pattern matching construct.</p></td></tr><tr id="type-termkind.TSel" class="anchored"><td class="def constructor"><a href="#type-termkind.TSel" class="anchor"></a><code>| </code><code><span class="constructor">TSel</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * Base.int</code></td><td class="doc"><p>A tuple projection. TSet(TTup tl, i) is List.nth tl i.</p></td></tr><tr id="type-termkind.TTup" class="anchored"><td class="def constructor"><a href="#type-termkind.TTup" class="anchor"></a><code>| </code><code><span class="constructor">TTup</span> <span class="keyword">of</span> <span><a href="index.html#type-term">term</a> Base.list</span></code></td><td class="doc"><p>A tuple.</p></td></tr><tr id="type-termkind.TUn" class="anchored"><td class="def constructor"><a href="#type-termkind.TUn" class="anchor"></a><code>| </code><code><span class="constructor">TUn</span> <span class="keyword">of</span> <a href="Unop/index.html#type-t">Unop.t</a> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A unary operation.</p></td></tr><tr id="type-termkind.TVar" class="anchored"><td class="def constructor"><a href="#type-termkind.TVar" class="anchor"></a><code>| </code><code><span class="constructor">TVar</span> <span class="keyword">of</span> <a href="index.html#type-variable">variable</a></code></td><td class="doc"><p>A variable.</p></td></tr></table></dt><dt class="spec type" id="type-match_case"><a href="#type-match_case" class="anchor"></a><code><span class="keyword">and</span> match_case</code><code> = <a href="index.html#type-pattern">pattern</a> * <a href="index.html#type-term">term</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">and</span> term</code><code> = </code><code>{</code><table class="record"><tr id="type-term.tpos" class="anchored"><td class="def field"><a href="#type-term.tpos" class="anchor"></a><code>tpos : Stdlib.Lexing.position * Stdlib.Lexing.position;</code></td></tr><tr id="type-term.tkind" class="anchored"><td class="def field"><a href="#type-term.tkind" class="anchor"></a><code>tkind : <a href="index.html#type-termkind">termkind</a>;</code></td></tr><tr id="type-term.ttyp" class="anchored"><td class="def field"><a href="#type-term.ttyp" class="anchor"></a><code>ttyp : <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-function_descr"><a href="#type-function_descr" class="anchor"></a><code><span class="keyword">type</span> function_descr</code><code> = </code><code>{</code><table class="record"><tr id="type-function_descr.f_var" class="anchored"><td class="def field"><a href="#type-function_descr.f_var" class="anchor"></a><code>f_var : <a href="index.html#type-variable">variable</a>;</code></td></tr><tr id="type-function_descr.f_args" class="anchored"><td class="def field"><a href="#type-function_descr.f_args" class="anchor"></a><code>f_args : <span><a href="index.html#type-pattern">pattern</a> Base.list</span>;</code></td></tr><tr id="type-function_descr.f_body" class="anchored"><td class="def field"><a href="#type-function_descr.f_body" class="anchor"></a><code>f_body : <a href="index.html#type-term">term</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-_globals"><a href="#val-_globals" class="anchor"></a><code><span class="keyword">val</span> _globals : <span><span>(Base.string, <a href="Variable/index.html#type-t">Variable.t</a> * <span><a href="index.html#type-fpattern">fpattern</a> Base.list</span> * <span><a href="index.html#type-term">term</a> Base.option</span> * <a href="index.html#type-term">term</a>)</span> Base.Hashtbl.t</span></code></dt><dt class="spec value" id="val-find_global"><a href="#val-find_global" class="anchor"></a><code><span class="keyword">val</span> find_global : Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-variable">variable</a> Base.option</span></code></dt><dt class="spec value" id="val-fpat_ty"><a href="#val-fpat_ty" class="anchor"></a><code><span class="keyword">val</span> fpat_ty : <a href="index.html#type-fpattern">fpattern</a> <span>&#45;&gt;</span> <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a></code></dt><dt class="spec value" id="val-fpat_vars"><a href="#val-fpat_vars" class="anchor"></a><code><span class="keyword">val</span> fpat_vars : <a href="index.html#type-fpattern">fpattern</a> <span>&#45;&gt;</span> <a href="VarSet/index.html#type-t">VarSet.t</a></code></dt><dt class="spec value" id="val-pattern_of_term"><a href="#val-pattern_of_term" class="anchor"></a><code><span class="keyword">val</span> pattern_of_term : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_pat_any"><a href="#val-mk_pat_any" class="anchor"></a><code><span class="keyword">val</span> mk_pat_any : <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_pat_var"><a href="#val-mk_pat_var" class="anchor"></a><code><span class="keyword">val</span> mk_pat_var : <a href="index.html#type-variable">variable</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_pat_const"><a href="#val-mk_pat_const" class="anchor"></a><code><span class="keyword">val</span> mk_pat_const : <a href="Constant/index.html#type-t">Constant.t</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_pat_tuple"><a href="#val-mk_pat_tuple" class="anchor"></a><code><span class="keyword">val</span> mk_pat_tuple : <span><a href="index.html#type-pattern">pattern</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_pat_constr"><a href="#val-mk_pat_constr" class="anchor"></a><code><span class="keyword">val</span> mk_pat_constr : Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-pattern">pattern</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dt class="spec value" id="val-mk_var"><a href="#val-mk_var" class="anchor"></a><code><span class="keyword">val</span> mk_var : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-variable">variable</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-var_or_none"><a href="#val-var_or_none" class="anchor"></a><code><span class="keyword">val</span> var_or_none : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-variable">variable</a> Base.option</span></code></dt><dt class="spec value" id="val-ext_var_or_none"><a href="#val-ext_var_or_none" class="anchor"></a><code><span class="keyword">val</span> ext_var_or_none : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-variable">variable</a> Base.list</span> Base.option</span></code></dt><dt class="spec value" id="val-mk_const"><a href="#val-mk_const" class="anchor"></a><code><span class="keyword">val</span> mk_const : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <a href="Constant/index.html#type-t">Constant.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_box"><a href="#val-mk_box" class="anchor"></a><code><span class="keyword">val</span> mk_box : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_app"><a href="#val-mk_app" class="anchor"></a><code><span class="keyword">val</span> mk_app : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_app_v"><a href="#val-mk_app_v" class="anchor"></a><code><span class="keyword">val</span> mk_app_v : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-variable">variable</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_bin"><a href="#val-mk_bin" class="anchor"></a><code><span class="keyword">val</span> mk_bin : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="Binop/index.html#type-t">Binop.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_assoc"><a href="#val-mk_assoc" class="anchor"></a><code><span class="keyword">val</span> mk_assoc : <a href="Binop/index.html#type-t">Binop.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.option</span></code></dt><dt class="spec value" id="val-mk_data"><a href="#val-mk_data" class="anchor"></a><code><span class="keyword">val</span> mk_data : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_fun"><a href="#val-mk_fun" class="anchor"></a><code><span class="keyword">val</span> mk_fun : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-fpattern">fpattern</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_ite"><a href="#val-mk_ite" class="anchor"></a><code><span class="keyword">val</span> mk_ite : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_tup"><a href="#val-mk_tup" class="anchor"></a><code><span class="keyword">val</span> mk_tup : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_sel"><a href="#val-mk_sel" class="anchor"></a><code><span class="keyword">val</span> mk_sel : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base.int <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_un"><a href="#val-mk_un" class="anchor"></a><code><span class="keyword">val</span> mk_un : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <a href="Unop/index.html#type-t">Unop.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_match"><a href="#val-mk_match" class="anchor"></a><code><span class="keyword">val</span> mk_match : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-match_case">match_case</a> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-mk_let"><a href="#val-mk_let" class="anchor"></a><code><span class="keyword">val</span> mk_let : <span>?&#8288;pos:<span>(Stdlib.Lexing.position * Stdlib.Lexing.position)</span></span> <span>&#45;&gt;</span> <span>?&#8288;typ:<span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> option</span></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-variable">variable</a> * <a href="index.html#type-term">term</a>)</span> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-term_of_pattern"><a href="#val-term_of_pattern" class="anchor"></a><code><span class="keyword">val</span> term_of_pattern : <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-fpat_to_term"><a href="#val-fpat_to_term" class="anchor"></a><code><span class="keyword">val</span> fpat_to_term : <a href="index.html#type-fpattern">fpattern</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-fpat_sub"><a href="#val-fpat_sub" class="anchor"></a><code><span class="keyword">val</span> fpat_sub : <a href="index.html#type-fpattern">fpattern</a> <span>&#45;&gt;</span> <a href="index.html#type-fpattern">fpattern</a> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a>)</span> Base.List.t</span> option</span></code></dt><dt class="spec value" id="val-fpat_sub_all"><a href="#val-fpat_sub_all" class="anchor"></a><code><span class="keyword">val</span> fpat_sub_all : <span><a href="index.html#type-fpattern">fpattern</a> Base.List.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-fpattern">fpattern</a> Base.List.t</span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a>)</span> Base__List.t</span> option</span></code></dt><dt class="spec value" id="val-sexp_of_term"><a href="#val-sexp_of_term" class="anchor"></a><code><span class="keyword">val</span> sexp_of_term : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base.Sexp.t</code></dt><dt class="spec value" id="val-mk_composite_base_type"><a href="#val-mk_composite_base_type" class="anchor"></a><code><span class="keyword">val</span> mk_composite_base_type : <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-term_compare"><a href="#val-term_compare" class="anchor"></a><code><span class="keyword">val</span> term_compare : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-substitution"><a href="#val-substitution" class="anchor"></a><code><span class="keyword">val</span> substitution : <span><span>(<a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a>)</span> Base__List.t</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-term_equal"><a href="#val-term_equal" class="anchor"></a><code><span class="keyword">val</span> term_equal : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mk_with_fresh_vars"><a href="#val-mk_with_fresh_vars" class="anchor"></a><code><span class="keyword">val</span> mk_with_fresh_vars : <a href="VarSet/index.html#type-t">VarSet.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="VarSet/index.html#type-t">VarSet.t</a> * <a href="index.html#type-term">term</a></code></dt></dl><div class="spec module" id="module-VarMap"><a href="#module-VarMap" class="anchor"></a><code><span class="keyword">module</span> <a href="VarMap/index.html">VarMap</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-rewrite_with"><a href="#val-rewrite_with" class="anchor"></a><code><span class="keyword">val</span> rewrite_with : <span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p>`rewrite_with f t` rewrites the term t by applying the rule f bottom-up.</p></dd></dl><dl><dt class="spec value" id="val-rewrite_top_down"><a href="#val-rewrite_top_down" class="anchor"></a><code><span class="keyword">val</span> rewrite_top_down : <span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p>`rewrite_top_down f t` rewrites the term t by applying the rule f top-down.</p></dd></dl><dl><dt class="spec value" id="val-rewrite_accum"><a href="#val-rewrite_accum" class="anchor"></a><code><span class="keyword">val</span> rewrite_accum : <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-term">term</a>, <span class="type-var">'a</span>)</span> Base.Either.t</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p>`rewrite_accum ~init ~f t` rewrites the term t by applying the rule f in a top-down manner, but as opposed to `rewrite_top_down` the function `f` can use an accumulator that accumulates information during the traversal.</p></dd></dl><dl><dt class="spec value" id="val-rewrite_types"><a href="#val-rewrite_types" class="anchor"></a><code><span class="keyword">val</span> rewrite_types : <span><span>(<a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> * <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>)</span> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>case:<span>(<span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.option</span>)</span></span> <span>&#45;&gt;</span> <span>join:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>`reduce ~init ~case ~join t` reduces the term by reducing each leaf to `init`, and at each node of the syntax tree, using `join` to merge the values. In a top-down traversal, if `case` returns `Some a` then the subterm is not recrusively reduced, but the value `a` is used instead.</p></dd></dl><dl><dt class="spec value" id="val-transform"><a href="#val-transform" class="anchor"></a><code><span class="keyword">val</span> transform : <span>case:<span>(<span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.option</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-transform_at_depth"><a href="#val-transform_at_depth" class="anchor"></a><code><span class="keyword">val</span> transform_at_depth : Base.int <span>&#45;&gt;</span> <span>case:<span>(<span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Base.option</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-transform_info"><a href="#val-transform_info" class="anchor"></a><code><span class="keyword">val</span> transform_info : <span>f:<span>(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-remove_boxes"><a href="#val-remove_boxes" class="anchor"></a><code><span class="keyword">val</span> remove_boxes : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-var_count"><a href="#val-var_count" class="anchor"></a><code><span class="keyword">val</span> var_count : <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base__Int.t</code></dt><dt class="spec value" id="val-var_count_compare"><a href="#val-var_count_compare" class="anchor"></a><code><span class="keyword">val</span> var_count_compare : <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-term_size"><a href="#val-term_size" class="anchor"></a><code><span class="keyword">val</span> term_size : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base__Int.t</code></dt><dt class="spec value" id="val-term_size_compare"><a href="#val-term_size_compare" class="anchor"></a><code><span class="keyword">val</span> term_size_compare : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-term_height"><a href="#val-term_height" class="anchor"></a><code><span class="keyword">val</span> term_height : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> Base__Int.t</code></dt><dt class="spec value" id="val-term_height_compare"><a href="#val-term_height_compare" class="anchor"></a><code><span class="keyword">val</span> term_height_compare : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-proj_var"><a href="#val-proj_var" class="anchor"></a><code><span class="keyword">val</span> proj_var : <a href="index.html#type-variable">variable</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p><code>proj_var v</code> returns the tuple term (v.0, v.1, ..., v.n) if <code>v</code> is a variable of tuple type with n compoenents, otherwise returns v as a term.</p></dd></dl><dl><dt class="spec value" id="val-tuplify"><a href="#val-tuplify" class="anchor"></a><code><span class="keyword">val</span> tuplify : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p><code>tuplify t</code> transforms every subterm of <code>t</code> that has a tuple type into a tuple of projections. For example if t is a term of tuple type with n components, it returns (t.1, t.2, .., t.n).</p></dd></dl><dl><dt class="spec value" id="val-pp_fpattern"><a href="#val-pp_fpattern" class="anchor"></a><code><span class="keyword">val</span> pp_fpattern : <span><a href="index.html#type-fpattern">fpattern</a> Fmt.t</span></code></dt><dt class="spec value" id="val-pp_pattern"><a href="#val-pp_pattern" class="anchor"></a><code><span class="keyword">val</span> pp_pattern : <span><a href="index.html#type-pattern">pattern</a> Fmt.t</span></code></dt><dt class="spec value" id="val-pp_term"><a href="#val-pp_term" class="anchor"></a><code><span class="keyword">val</span> pp_term : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_subs"><a href="#val-pp_subs" class="anchor"></a><code><span class="keyword">val</span> pp_subs : Base.Formatter.t <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a>)</span> Base.list</span> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp_function_descr"><a href="#val-pp_function_descr" class="anchor"></a><code><span class="keyword">val</span> pp_function_descr : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-function_descr">function_descr</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-infer_type"><a href="#val-infer_type" class="anchor"></a><code><span class="keyword">val</span> infer_type : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> * <a href="../Lang/RType/index.html#type-substitution">Lang.RType.substitution</a></code></dt><dt class="spec value" id="val-erase_term_type"><a href="#val-erase_term_type" class="anchor"></a><code><span class="keyword">val</span> erase_term_type : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dt class="spec value" id="val-type_of"><a href="#val-type_of" class="anchor"></a><code><span class="keyword">val</span> type_of : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a></code></dt></dl><div class="spec module" id="module-Terms"><a href="#module-Terms" class="anchor"></a><code><span class="keyword">module</span> <a href="Terms/index.html">Terms</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-TermSet"><a href="#module-TermSet" class="anchor"></a><code><span class="keyword">module</span> <a href="TermSet/index.html">TermSet</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_term_set"><a href="#val-pp_term_set" class="anchor"></a><code><span class="keyword">val</span> pp_term_set : Base.Formatter.t <span>&#45;&gt;</span> <a href="TermSet/index.html#type-t">TermSet.t</a> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>